#      Markingpy automatic grading tool for Python code.
#      Copyright (C) 2019 University of East Anglia
#
#      This program is free software: you can redistribute it and/or modify
#      it under the terms of the GNU General Public License as published by
#      the Free Software Foundation, either version 3 of the License, or
#      (at your option) any later version.
#
#      This program is distributed in the hope that it will be useful,
#      but WITHOUT ANY WARRANTY; without even the implied warranty of
#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#      GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public License
#      along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
"""
Syntax checking interface.
"""
import json
import tempfile
import collections
import os
import ast
import types

from abc import ABC, abstractmethod
from contextlib import contextmanager

from typing import TYPE_CHECKING

from pylint.epylint import py_run

from .import config
from .import utils

if TYPE_CHECKING:
    from .import submission
__all__ = [
    'CodeStyleCheckerABC', 'CodeStyleCheckerABC', 'PyLintChecker', 'PyLintReport'
]


PYTHON_STATEMENT_NAMES = [
        "FunctionDef",
        "AsyncFunctionDef",
        "ClassDef",
        "Return",
        "Delete",
        "Assign",
        "AugAssign",
        "AnnAssign",
        "For",
        "AsyncFor",
        "While",
        "If",
        "With",
        "AsyncWith",
        "Raise",
        "Try",
        "Assert",
        "Import",
        "ImportFrom",
        "Global",
        "Nonlocal",
        "Expr",
        "Pass"
        "Break",
        "Continue",
        ]


class _StatementCounter(ast.NodeVisitor):
    """
    Helper class to count the number of statements in Python source.
    """

    def __init__(self):
        self.statements = 0


def _statement_visitor(self, node):
    self.statements += 1
    self.generic_visit(node)


def _ns_prep(ns):
    return ns.update({
            f"visit_{name}": _statement_visitor
            for name in PYTHON_STATEMENT_NAMES
            })

StatementCounter = types.new_class(
        "StatementCounter",
        (_StatementCounter,),
        exec_body=_ns_prep)


def count_statements(root_node):
    cntr = StatementCounter()
    cntr.visit(root_node)
    return cntr.statements


class CodeStyleReportABC(ABC):
    """
    Abstract base class for syntax reports.
    """

    @abstractmethod
    def get_text_report(self):
        pass

    @abstractmethod
    def get_stats(self):
        pass

    @abstractmethod
    def get_score(self):
        pass


class CodeStyleCheckerABC(ABC):
    """
    Abstract base class for code style checkers (linter) interface.)
    """

    @abstractmethod
    def check(self, sub: 'submission.Submission') -> CodeStyleReportABC:
        pass


class PyLintReport(CodeStyleReportABC):
    """
    Report generated by PyLintChecker
    """

    def __init__(self, messages, statements, calc, max_score):
        self.messages = messages
        self.statements = statements
        self.calc = calc
        self.max_score = max_score

    def get_stats(self):
        stats = collections.Counter(m['type'] for m in self.messages)
        stats['statements'] = self.statements
        return stats

    def get_text_report(self):
        template = config.GLOBAL_CONF['pylint']['msg_template']
        return '\n'.join(template.format(**m) for m in self.messages)

    def get_score(self):
        if self.calc is None:
            raise RuntimeError

        return self.calc(self.get_stats())


class PyLintChecker(CodeStyleCheckerABC):
    """
    Code style checker using PyLint as a backend
    """

    def __init__(self, score_formula=None, max_score=None, **params):
        if score_formula is not None:
            self.calc = utils.build_style_calc(score_formula)
            self.max_score = 10.0
        else:
            self.calc = utils.default_style_calc
            self.max_score = max_score if max_score is not None else 10.0
        self.cli_args = args = []
        params.update(output_format='json')
        for k, v in params.items():
            args.append(f'--{k.replace("_", "-")}={v}')

    @contextmanager
    def prepare_file(self, sub):
        file = tempfile.NamedTemporaryFile(mode='w+t', suffix='.py', delete=False)
        file.write(sub.raw_source)
        file.close()
        try:
            yield file.name

        finally:
            os.unlink(file.name)

    def check(self, sub):
        with self.prepare_file(sub) as path:
            cli_args = [path] + self.cli_args
            (stdout, stderr) = py_run(" ".join(cli_args), return_std=True)
        return PyLintReport(
            json.loads(stdout.read()), count_statements(ast.parse(
                        sub.raw_source)), self.calc, self.max_score
        )
